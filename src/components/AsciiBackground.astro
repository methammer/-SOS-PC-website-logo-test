---
// No server-side logic needed for the component itself
---
<canvas id="ascii-background-canvas"></canvas>

<style>
  #ascii-background-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    opacity: 0.15; /* Adjusted for potentially brighter characters */
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('ascii-background-canvas') as HTMLCanvasElement;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // --- Configuration ---
    const charSet = ['.', ':', '-', '|', '*', '+', '~'];
    const baseFontSize = 16;
    const updateInterval = 200;
    const changeProbability = 0.02;

    const lightThemeAsciiColors = ['#6c757d', '#5a6268', '#495057', '#343a40', '#212529'];
    const darkThemeAsciiColors = ['#E0E0E0', '#BDBDBD', '#EEEEEE', '#F5F5F5', '#E8EAF6'];
    
    // Mouse effect configuration
    const mouseEffectRadius = 150; // Pixels
    const maxBrightnessIncrease = 0.8; // 0 to 1, how much to brighten towards white

    let currentAsciiColors: string[] = [];
    let dpr = window.devicePixelRatio || 1;

    let cols: number;
    let rows: number;
    let grid: { char: string; color: string }[][] = [];
    
    let lastCharUpdateTime = 0;
    let mouseX = -Infinity; // Initialize mouse position off-screen
    let mouseY = -Infinity;

    // --- Helper Functions for Color Manipulation ---
    function hexToRgb(hex: string): { r: number; g: number; b: number } | null {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    }

    function rgbToHex(r: number, g: number, b: number): string {
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
    }

    function brightenColor(hexColor: string, factor: number): string {
      const rgb = hexToRgb(hexColor);
      if (!rgb) return hexColor;

      // Increase brightness: move each component towards 255
      // Clamp factor between 0 and 1
      const clampedFactor = Math.max(0, Math.min(1, factor));

      const r = Math.min(255, Math.round(rgb.r + (255 - rgb.r) * clampedFactor));
      const g = Math.min(255, Math.round(rgb.g + (255 - rgb.g) * clampedFactor));
      const b = Math.min(255, Math.round(rgb.b + (255 - rgb.b) * clampedFactor));
      
      return rgbToHex(r, g, b);
    }

    // --- Core Logic ---
    function updateThemeColors() {
      if (document.documentElement.classList.contains('dark')) {
        currentAsciiColors = darkThemeAsciiColors;
      } else {
        currentAsciiColors = lightThemeAsciiColors;
      }
    }

    function initializeGridData() {
      cols = Math.ceil(window.innerWidth / baseFontSize);
      rows = Math.ceil(window.innerHeight / baseFontSize);

      grid = [];
      for (let y = 0; y < rows; y++) {
        grid[y] = [];
        for (let x = 0; x < cols; x++) {
          grid[y][x] = {
            char: charSet[Math.floor(Math.random() * charSet.length)],
            color: currentAsciiColors[Math.floor(Math.random() * currentAsciiColors.length)],
          };
        }
      }
    }

    function setupCanvas() {
      updateThemeColors();
      dpr = window.devicePixelRatio || 1;

      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      ctx.scale(dpr, dpr);

      ctx.font = `${baseFontSize}px monospace`;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      
      initializeGridData();
    }

    function draw() {
      ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const cell = grid[y][x];
          if (cell) {
            const charX = x * baseFontSize + baseFontSize / 2; // Center of the character cell
            const charY = y * baseFontSize + baseFontSize / 2;
            
            const distanceToMouse = Math.sqrt(Math.pow(charX - mouseX, 2) + Math.pow(charY - mouseY, 2));
            let displayColor = cell.color;

            if (distanceToMouse < mouseEffectRadius) {
              const intensity = 1 - (distanceToMouse / mouseEffectRadius); // 1 at center, 0 at edge
              const brightnessFactor = intensity * maxBrightnessIncrease;
              displayColor = brightenColor(cell.color, brightnessFactor);
            }
            
            ctx.fillStyle = displayColor;
            ctx.fillText(cell.char, x * baseFontSize, y * baseFontSize);
          }
        }
      }
    }

    function updateCharacterGridContent() {
       for (let y = 0; y < rows; y++) {
         for (let x = 0; x < cols; x++) {
           if (grid[y] && grid[y][x] && Math.random() < changeProbability) { 
              grid[y][x].char = charSet[Math.floor(Math.random() * charSet.length)];
              // Only update base color here, mouse effect is applied during draw
              grid[y][x].color = currentAsciiColors[Math.floor(Math.random() * currentAsciiColors.length)];
           }
         }
       }
    }

    function animate(timestamp: number) {
      const deltaTime = timestamp - lastCharUpdateTime;
      if (deltaTime > updateInterval) {
        updateCharacterGridContent();
        lastCharUpdateTime = timestamp;
      }

      draw(); 
      requestAnimationFrame(animate);
    }

    // --- Event Listeners ---
    window.addEventListener('mousemove', (event) => {
      mouseX = event.clientX;
      mouseY = event.clientY;
    });
    
    // Optional: Reset mouse position when it leaves the window to avoid lingering effect
    window.addEventListener('mouseout', () => {
      mouseX = -Infinity;
      mouseY = -Infinity;
    });


    setupCanvas();

    let resizeTimeout: number;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(() => {
        setupCanvas();
      }, 250);
    });

    const themeObserver = new MutationObserver((mutationsList) => {
      for (const mutation of mutationsList) {
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          const previousColorsString = JSON.stringify(currentAsciiColors);
          updateThemeColors();
          if (JSON.stringify(currentAsciiColors) !== previousColorsString) {
            setupCanvas(); 
          }
          break;
        }
      }
    });

    themeObserver.observe(document.documentElement, { attributes: true });

    requestAnimationFrame(animate);
  });
</script>
